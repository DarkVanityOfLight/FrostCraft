package generators

import Manager
import net.axay.kspigot.event.listen
import net.axay.kspigot.extensions.geometry.SimpleLocation3D
import net.axay.kspigot.gui.GUIType
import net.axay.kspigot.gui.Slots
import net.axay.kspigot.gui.kSpigotGUI
import net.axay.kspigot.gui.openGUI
import net.kyori.adventure.text.Component
import org.bukkit.Bukkit
import org.bukkit.Material
import org.bukkit.World
import org.bukkit.block.Block
import org.bukkit.block.Chest
import org.bukkit.block.data.type.Furnace
import org.bukkit.event.player.PlayerInteractEvent
import org.bukkit.inventory.ItemStack
import zones.HeatZone
import kotlin.math.pow

/**
 * Represents the state of the generator.
 */
enum class GeneratorState {
    ON, OFF, POWERING_ON, POWERING_OFF
}

/**
 * Represents a generator in the game.
 *
 * @property radius The radius of the generator's effect.
 * @property origin The origin location of the generator.
 * @property controller The block that controls the generator.
 * @property consumption The fuel consumption rate of the generator.
 * @property heat The heat generated by the generator.
 * @property durability The durability of the generator.
 * @property world The world the generator is in.
 */
class Generator(
    private var radius: Int,
    private val origin: SimpleLocation3D,
    private val controller: Block,
    private var consumption: Int,
    private var heat: Float,
    private var durability: Float,
    private val world: World
) {
    private val structure: MutableSet<Block> = mutableSetOf()
    private var stress: Float = 0.0f
    private val intakes: MutableSet<Block> = mutableSetOf()
    private var state: GeneratorState = GeneratorState.OFF
    private var consumerId: Int? = null

    init {
        // Listen for player interaction events to open the generator control panel
        listen<PlayerInteractEvent> {
            if (it.clickedBlock == controller) {
                val gui = kSpigotGUI(GUIType.ONE_BY_FIVE) {
                    defaultPage = 1
                    title = Component.text("Generator control panel")

                    page(1) {
                        placeholder(Slots.Border, ItemStack(Material.BLACK_STAINED_GLASS_PANE))

                        if (state == GeneratorState.OFF) {
                            val stack = ItemStack(Material.GREEN_WOOL)
                            stack.itemMeta = stack.itemMeta.apply {
                                displayName(Component.text("Power on"))
                            }
                            button(Slots.RowOneSlotThree, stack) {
                                findIntakes()
                                powerOn()
                                it.player.closeInventory()
                            }
                        } else {
                            val stack = ItemStack(Material.RED_WOOL)
                            stack.itemMeta = stack.itemMeta.apply {
                                displayName(Component.text("Power off"))
                            }
                            button(Slots.RowOneSlotThree, stack) {
                                powerOff()
                                it.player.closeInventory()
                            }
                        }
                    }
                }

                it.player.openGUI(gui)
                it.isCancelled = true
            }
        }
    }

    /**
     * Generates a climate zone around the generator.
     */
    private fun generateZone() {
        val heatZone = HeatZone(world, origin, radius.toFloat()) { globalTemp, distance ->
            globalTemp + (heat / distance.toDouble().pow(2.0).toFloat())
        }

        Manager.climateManager.addClimateZone(heatZone)

    }

    /**
     * Removes the climate zone around the generator.
     */
    private fun removeZone() {
        Manager.climateManager.removeClimateZoneAt(world, origin)
    }

    /**
     * Consumes fuel from the generator's intakes.
     * If no fuel is available, the generator is powered off.
     */
    private fun consumeFuel() {
        if (!hasFuel()) {
            powerOff()
            return
        }

        for (intake in intakes) {
            if ((intake.state as Chest).blockInventory.contains(Material.COAL)) {
                (intake.state as Chest).blockInventory.removeItem(ItemStack(Material.COAL, consumption))
                break
            }
        }
    }

    /**
     * Checks if the generator has fuel in its intakes.
     *
     * @return True if fuel is available, false otherwise.
     */
    private fun hasFuel(): Boolean {
        for (intake in intakes) {
            if ((intake.state as Chest).blockInventory.contains(Material.COAL)) {
                return true
            }
        }
        return false
    }

    /**
     * Powers on the generator.
     * Turns on all furnaces in the structure and starts fuel consumption.
     */
    fun powerOn() {
        if (!hasFuel()) {
            Bukkit.getLogger().info("No fuel")
            return
        }

        Bukkit.getLogger().info("Powering on generator")

        structure.forEach { block ->
            if (block.type == Material.FURNACE) {
                val f: Furnace = (block.state.blockData as Furnace)
                f.isLit = true
                block.blockData = f
                block.state.update()
            }
        }

        generateZone()

        consumerId = Bukkit.getScheduler().scheduleSyncRepeatingTask(Manager, this::consumeFuel, 5, 20)

        if (consumerId == -1) {
            Bukkit.getLogger().severe("Failed to start generator consumer")
        }

        this.state = GeneratorState.ON
    }

    /**
     * Powers off the generator.
     * Turns off all furnaces in the structure and stops fuel consumption.
     */
    fun powerOff() {
        Bukkit.getScheduler().cancelTask(consumerId!!)
        consumerId = null

        structure.forEach { block ->
            if (block.type == Material.FURNACE) {
                val f: Furnace = (block.state.blockData as Furnace)
                f.isLit = false
                block.blockData = f
                block.state.update()
            }
        }

        removeZone()

        this.state = GeneratorState.OFF
    }

    /**
     * Finds and adds all chest blocks in the structure to the intakes set.
     */
    fun findIntakes() {
        structure.forEach { block ->
            if (block.type == Material.CHEST) {
                intakes.add(block)
            }
        }
    }

    /**
     * Adds a block to the generator's structure.
     *
     * @param block The block to add.
     */
    fun addBlock(block: Block) {
        structure.add(block)
    }

    /**
     * Adds multiple blocks to the generator's structure.
     *
     * @param blocks The list of blocks to add.
     */
    fun addBlocks(blocks: List<Block>) {
        structure.addAll(blocks)
    }
}